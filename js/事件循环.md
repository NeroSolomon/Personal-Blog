## 事件循环
事件循环是基于任务队列的

### 任务队列
一个事件循环中，可以有一个或多个任务队列，来自于不同任务源的任务放在同一个任务队列中<br>
任务源有以下类型setTimeout、promise、click事件、ajax onload事件、I/O等<br>
而任务分为宏任务和微任务，宏任务在宏任务队列，微任务在微任务队列

### 事件循环流程
一次循环操作称为tick，关键步骤如下：
1. 取出最先进入队列的任务，如果有则执行
2. 如果微任务队列存在微任务，则不断执行，直到清空微任务队列
3. 渲染dom
4. 重复1

### 浏览器机制
1. 先把同步任务放入执行栈
2. 异步任务有了运行结果后，就在任务队列中放置一个事件
3. 执行栈中所有同步任务执行完，也可以说每次执行栈里面执行的代码就是一个宏任务
4. 取出任务队列里面可执行的任务添加到执行栈中，开始执行，先执行微任务（promise），再执行宏任务（setTimeout）

### 真题
```js
document.body.addEventListener('click', () => {
  Promise.resolve().then(()=>console.log(1));
  console.log(2)
  setTimeout(() => console.log(5), 0)
});
document.body.addEventListener('click', () => {
  Promise.resolve().then(()=>console.log(3));
  console.log(4)
  setTimeout(() => console.log(6), 0)
});
```
### 真题答案
2 - 1 - 4 - 3 - 5 - 6

### 真题解析
1. 首先先把同步任务放入执行栈，
2. click事件为一个事件源，回调函数是其任务队列中的任务
3. 首先先取出第一个click事件中的任务，放到执行栈，执行
4. 执行过程中，先执行同步代码，输出2
5. 执行宏任务中产生的微任务，输出1
6. 将宏任务中产生的宏任务放到任务队列中
8. 渲染
9. 取出第二个click事件中的任务，，放到执行栈，执行
10. 执行过程中，先执行同步代码，输出4
11. 执行宏任务中产生的微任务，输出3
12. 将宏任务中产生的宏任务放到任务队列中
13. 渲染
13. 在执行栈中执行第一个click回调产生的宏任务：setTimeout，输出5
14. 渲染
15. 在执行栈中执行第二个click回调产生的宏任务：setTimeout，输出6
16. 渲染

### 事件队列中的宏任务和微任务
在前端的JavaScript执行环境中，事件队列（Event Loop）处理异步操作是非常重要的概念。这里面牵涉到两类任务：宏任务（Macro tasks）和微任务（Microtasks）。理解这两者的区别对于编写高效且可预测的JavaScript代码很有帮助。

宏任务 (Macro tasks)
宏任务可以视为一些比较大的、独立的工作单元。每次执行一个宏任务后，引擎都会检查是否需要进行渲染更新或其他系统任务。下面是一些产生宏任务的源：

setTimeout
setInterval
I/O
用户交互（如点击或键盘事件）
传统的 script 标签等
宏任务通常表示一个分明的开始到结束的过程，而每个宏任务之间可能包含UI渲染时机。

微任务 (Microtasks)
微任务通常是在当前运行的脚本完成后、下一个宏任务开始前的过程中执行的小任务。也就是说，在同一个宏任务内部，所有微任务总是在进入下一个宏任务前被清空执行。微任务用于处理应该立即执行但又不阻塞主线程的简短作业。以下是生成微任务的几种方式：

Promise.then() 或 Promise.catch()
MutationObserver
queueMicrotask() 方法
如果有多个微任务被排队，它们将按顺序执行，并且必须在开始新的宏任务之前全部执行完毕。

区别
执行时机不同：

宏任务：每次执行完一个宏任务，都有机会去做渲染操作。
微任务：在任何宏任务结束之后、通常在进行渲染前处理所有的微任务队列。
任务队列数量不同：

对于宏任务来说，多个宏任务都有各自的队列；
对于微任务来说，所有微任务放入一个队列中，按照顺序执行。
响应速度：

微任务的响应时间通常更快，因为微任务确保在当前宏任务尽可能早的阶段执行。