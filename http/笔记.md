## 笔记

### session，cookie， token
cookie存在客户端，每次调用接口传给服务器<br>
session存在服务器端，生成一个session_id存在cookie中，每次访问服务器，会对比session_id<br>
token是服务器生成的返回的，客户端在访问时将token放在请求头中传给服务端，服务器拿到token后和数据库中的字段对照<br>
项目中使用token的例子
1. 登录后api返回token，客户端将其存到cookie中
2. 每次请求接口，将token从cookie中拿出来，放到http头请求接口，接口校验token是否过期

refer: 
1. https://worktile.com/kb/p/38734

### http 和 https的区别
https是http通过ssl协议加密后的协议
[参考链接](https://www.cnblogs.com/wqhwe/p/5407468.html)

### https
HTTPS的原理详细解释
‌加密算法‌：HTTPS使用‌对称加密和非对称加密两种加密算法。对称加密使用相同的密钥进行加密和解密，速度快但密钥传输过程容易被拦截。非对称加密使用一对公钥和私钥，公钥用于加密，私钥用于解密，安全性较高但速度较慢。

‌‌数字证书‌：数字证书是由权威的第三方认证机构（CA）颁发的一种用于证明网站身份的电子文件。证书包含了网站的公钥、域名和证书的有效期等信息。用户在访问网站时，浏览器会自动验证数字证书的有效性，如果证书有效，浏览器会显示安全锁标志。

‌SSL/TLS协议‌：SSL（安全套接层）和TLS（传输层安全）协议是HTTPS的基础，用于在客户端和服务器之间建立安全连接。SSL/TLS协议包括握手协议、记录协议、警告协议和变更密码规范协议。握手协议用于协商加密算法和交换密钥；记录协议用于对数据进行加密和解密；警告协议用于传输警告信息；变更密码规范协议用于通知对方即将使用新的加密参数。

‌握手过程‌：在HTTPS的握手阶段，服务器会发送其证书给客户端，客户端验证证书的有效性后，双方协商一个对称加密的密钥进行后续的数据传输。这个过程确保了通信的安全性和身份认证。

### 三次挥手和四次握手
https://blog.csdn.net/Reggie97/article/details/137602942

### http1.0，http1.x, http2, https
1.http1.0和http1.x的区别
a) 缓存字段更新：http1.0的If-Modified-Since,Expires，http1.x加入Entity tag，If-Unmodified-Since, If-Match, If-None-Match<br>
b) 添加了一些有关错误信息的http状态码，409：请求资源冲突，410表示服务器上某个资源被永久删除<br>
c) 在头部添加host头域<br>
d) http1.x可以采用connection: keep-alive建立长连接<br>

2.http1.x和http2的区别<br>
a) http1.x是基于文本的解析，文本有多种表现形式，无法做到健壮性。http2使用的是二进制解析，只有01的组合不用考虑太多<br>
b) http2可以在同一个连接上做多个请求<br>
c) http2通过客户端和服务端共同维护一份字典，将已发送且没有改动的头部不重复发送，借此压缩头部。<br>
d) http2可以通过服务端推送主动推送资源给客户端

### 如何检查资源是否命中CDN缓存
查看资源的headers的x-cache字段，如果显示是MISS：没有命中CDN缓存，是回源的。如果显示是HIT，证明命中缓存

### 跨域请求的预请求
我们会发现，在很多post,put,delete等请求之前，会有一次options请求<br>
W3C规范这样要求了！在跨域请求中，分为简单请求（get和部分post，post时content-type属于application/x-www-form-urlencoded，multipart/form-data，text/plain中的一种）和复杂请求。而复杂请求发出之前，就会出现一次options请求。<br>
在ajax中出现options请求，也是一种提前探测的情况，ajax跨域请求时，如果请求的是json，就属于复杂请求，因此需要提前发出一次options请求，用以检查请求是否是可靠安全的，如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、put等请求的发出。<br>
前台跨域post请求，由于CORS（cross origin resource share）规范的存在，浏览器会首先发送一次options嗅探，同时header带上origin，判断是否有跨域请求权限，服务器响应access control allow origin的值，供浏览器与origin匹配，如果匹配则正式发送post请求。<br>

### 今天闹了一个大笑话，当页面访问不了的时侯，什么表现才是cdn问题，什么表现是网络问题
1. cdn问题导致找不到资源文件的时侯，会显示404<br>
2. 当网络出现问题的时侯，会显示无法访问页面，网络响应过长

### ajax的工作流程
1. 创建XMLHttpRequest对象
2. 通过onreadystatechange监听readyState的变化
2. 打开链接
3. 发送请求，如果是post方法要写请求头
4. 接受服务器的返回，根据XMLHttpRequest的readyState属性判定调用哪个回调函数
5. 更新页面

### BS/CS
BS: Browser-Server 客户端是浏览器 也可以理解为web 这个受同源策略限制<br>
CS: Client-Server 客户端是原生客户端 这个不受同源策略限制

### 假如服务端使用了gzip，在response headers中会展示：content-encoding:gzip

## 强缓存和协商缓存：
强缓存是每次都通过标示判断缓存是否失效，没有失效从代理服务器（nginx）中获取缓存，失效则去服务器中取新资源，不一定要访问服务器，cache-control<br>
1.  cache-control: max-age=xxxx，public
    客户端和代理服务器都可以缓存该资源；
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求

2.  cache-control: max-age=xxxx，private
    只让客户端可以缓存该资源；代理服务器不缓存
    客户端在xxx秒内直接读取缓存,statu code:200

3.  cache-control: max-age=xxxx，immutable
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

4.  cache-control: no-cache
    跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

5.  cache-control: no-store
    不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。
协商缓存是每次都拿服务器返回的标识：etag（hash值）、last-modified去访问服务器，是否需要更新资源还是使用缓存

## 命令行抓包
1. sudo tcpdump -i any -n -w ./Downloads/client.pcap // 生成文件
2. sudo tcpdump -i any -n host 45.253.144.15 // 定向抓包

## CNAME
CNAME 被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“r0WSPFSx58.”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。

同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即CNAME)到A记录的域名上；那么当您的服务器IP地址变更时，您就可以不必对一个一个域名做更改指向了，只需要更改A记录的那个域名到服务器新IP上，其他做别名（即CNAME）的那些域名的指向将自动更改到新的IP地址上（以上操作均需要在DNS处执行）

## http报文格式

HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：

起始行（start line）描述请求或响应的基本信息：method url httpcode
头部字段集合（header）使用 key-value 形式更详细说明报文
消息正文（entity）实际传输的数据，不一定是纯文本，可以是图片、视频等二进制数据

### 浅谈从浏览器输入URL到页面渲染的流程 
浏览器输入URL到页面渲染完成，这个过程大致可分为两个阶段：网络通信和页面渲染。

一、网络通信

互联网内各网络间设备的通信遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层与对方通信。数据传输的过程：由应用层产生数据后，经过传输层的分段处理（添加TCP或UDP包头）、网络层（添加IP地址信息）、数据链路层（封装成MAC帧）、物理层传输电信号。

浏览器输入URL：

1.1、浏览器根据域名查找IP地址

在浏览器中输入域名 jd.com后，查找IP地址分为两个部分：客户机本地的递归查询和服务器的迭代查询。

<1> 客户机本地的递归查询：

客户机本地会依次去查找浏览器本身的域名缓存、客户机系统自身的缓存、客户机系统中的hosts文件，如果在当前的缓存中找到了对应的IP地址映射，则直接返回，如果在本地的缓存中都未找到对应的IP地址，则会去服务器查询。

<2> 服务器的迭代查询：

如果本地配置的服务器没有缓存相域名的IP，那么它就会去ISP运营商服务器去查找，如果也没有，运营商的服务器会返回给本地服务器一个根域的服务器地址。然后去根服务器发起访问，进行递归查询，如果也没有，就会去顶级域名的服务器去查找.com，然后再查找觉得jd.com的二级域名的服务器，以此类推就能找到相应的IP。如果仍然未找到，代表域名是错误的。

1.2、浏览器发送HTTP请求

找到IP地址后，则向对应IP地址的服务发送HTTP请求，HTTP请求消息包括请求起始行、请求头和请求主体

1）请求消息起始行：

包括：请求方法、请求URI（请求地址报过URL和URN）、协议版本。

2）请求头

包括：请求消息的专用头（ Host、Accept、Origin、Referer、User-Agent、Accept-Encoding、Accept-Language）、请求消息通用头（Connection、Cache-Control、Pragma、Date）、请求主体描述头（Content-Length、Content-Type）

3）请求主体（Body）

客户端想给服务器传递的消息。

1.3、TCP传输报文

TCP把应用层发送的用于网间传输的、用8位字节表示的数据流分成适当长度的报文段（报文段的长度不能超过MTU限制）。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包按序接收。然后接收端实体对已成功收到的包发回一个响应的确认（ACK）；如果发送端实体在合理的往返延时（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。当TCP要发送数据时，需要通过三次握手协议建立连接。之后TCP把结果包传给IP层由它通过网络将包传送给接收端实体的TCP层。

第一次握手：客户端发送syn包到服务器，并进入SYN_SENT状态，等待服务器的确认。 第二次握手：服务器收到syn包，必须确认客户端的syn，同时自己也发送一个syn包，即SYN+ACK包，此时服务器进入SYN_RECV状态。 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此包发送完毕，客户端与服务器端进入ESTABLISHED状态，即TCP连接成功，完成三次握手。

1.4、IP协议查询MAC地址并将数据发送的数据链路层

IP协议的作用是把TCP分割好的各种数据包传送给接收方，要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更改，但是MAC地址一般是固定不变的。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。

ARP是地址解析协议，功能是根据IP地址获取物理地址的一个TCP/IP 协议，即把IP地址转化为MAC地址。发送方首先检查ARP缓存表，查找目的地址的IP与MAC地址。如果存在地址中，直接使用ARP协议解析，完成的封装，传输数据。如果不存在目的地址的MAC地址，则发送一个ARP广播（包含本主机的IP地址、MAC地址、目的主机的IP地址）。网络中主机接收到广播后，先检查自己的IP地址，不符合丢弃该广播，符合则把源主机的IP地址和MAC地址映射添加到本地ARP缓存中，并向源主机发出ARP应答（包含自己的IP地址和MAC地址）。源主机收到应答后，把目标主机的IP和MAC地址添加到缓存中，然后开始进行通信。

在找到对方的MAC地址后，将数据发送到数据链路层传输，此时客户端发送阶段结束。

1.5、服务器接收数据并相应请求返回相应的文件

接收端的服务器在链路层接收到数据，然后再一层层去掉添加的首部。这个过程包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。然后服务器发送HTTP响应。HTTP的响应消息包括响应起始行、响应头、响应主体。

1）响应起始行：

包括：协议版本、空格、响应状态码、空格、原因短句（描述给你的状态码的原因）。

2）响应头

包括：响应消息的专用头（ Server、Last-Modified、Content-Encoding）、响应消息通用头（Connection、Cache-Control、Pragma、Date）、请求主体描述头（Content-Length、Content-Type）

3）响应主体描述头

客户端想给服务器传递的消息。

二、页面渲染

请求成功后，服务器返回给浏览器的文本信息，通常包括HTML、CSS、JS、图片等文件。不同浏览器内核由于内核不同，怼页面的渲染的过程也不相同。

webkit的渲染过程：

Gecko的渲染过程：

渲染的基本流程：HTML解析DOM Tree、CSS解析Style Rules、将两者关联生成Render Tree、Layout根据Render Tree计算每个节点的信息、Painting根据计算好的信息绘制整个页面。

2.1、HTML解析

HTML Parser的任务是将HTML标签解析成DOM Tree

<!DOCTYPE html>

<htmllang="en">

<head>

<metacharset="UTF-8">

<title>Document</title>

</head>

<body>

<p>p标签的内容</p>

<div>div标签的内容</div>

</body>

</html>

经过解析后的DOM Tree

2.2、CSS解析

CSS Parser将CSS解析成Style Rules，Style Rules也叫CSSOM（CSS Object Model），CSS Parser的作用就是将很多个CSS文件中的样式合并解析出具体树形结构。

2.3、js脚本处理、呈现树

浏览器解析文档时，当遇到标签的时候会立即解析脚本，停止解析文档，因为java可能会改动DOM和CSS，所以继续解析会造成浪费。如果脚本是外部的，会等待下载完毕，再继续解析文档。脚本解析会将脚本中的DOM和CSS的地方分别解析出来，然后追加到DOM Tree和Style Rules上。

Render Tree的构建其实就是DOM Tree和CSSOM attach的过程。实际上就是一个计算好的样式与HTML对应的Tree。

2.4、样式计算

计算样式是一个很复杂的过程，DOM中一个元素可以对应样式表中的多个样式，样式表包含了所有的样式：浏览器默认样式、自定义样式表、inline样式表元素、HTML可视化属性。为了简化样式计算，Friefox还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。

样式上下文树包含端值，要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。样式对象具有与每个可视化属性一一对应的属性（均为CSS属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承，其他属性具有默认值。

2.5、布局并绘制

创建渲染树后，下一步就是布局（Layout），或者叫回流（reflow，relayout），这个过程就是通过渲染树中的渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或回流的方法，实现其布局或回流。

在绘制的阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成。CSS2规范定义了绘制流程的顺序，绘制的顺序其实就是元素进入堆栈样式上下文的顺序，这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：背景颜色、背景图片、边框、子代、轮廓。

经过上述一序列的请求和渲染，就形成了浏览器中所展示的页面