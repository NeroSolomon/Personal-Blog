## python web 学习路线
https://zhuanlan.zhihu.com/p/28500969

1. 第一阶段

- 数据类型
- 流程控制
- 常用模块
- 函数、迭代器、装饰器
- 递归、迭代、反射
- 面向对象编程

2. 第二阶段

- html/css 基础
- Dom 编程
- 原生 JS 学习
- JQuery、EasyUi、AngulaJS
- Ajax 异步加载
- Highchart 画图
- Bootstrap

3. 第三阶段

- Socket c/s 编程、Twisted 异步网络框架
多线程、多进程、携程 gevent 、select\poll\epoll
- FTP 服务器开发
- 批量命令、文件分布工具
- RabbitMQ 消息队列、SqlAlchemy ORM
- Reids\MemCache\MongoDB 缓存数据库

4. 第四阶段

- Django
- Tornado
- Flask
- Bottle
- Session/中间件/ORM/Cookie/CSRF/FORM

## 包和模块的区别
包是一个文件夹，可以直接运行；模块是个py文件

## 面试题
1. https://blog.csdn.net/a55656aq/article/details/123084030
2. https://zhuanlan.zhihu.com/p/54430650

## __name__
1. 直接运行的话为__main__
2. 引入的话，不为__main__，为模块名

## 结构赋值

```python
import sys
import os
def test(user, project,  *args, name, **kwargs):
    print(args) # ('auth.sa',)
    print(kwargs) # {'t': '1d'}
    print(user) # tanmingyang
    print(name) # tanmingyang01
    
args = ['tanmingyang', 'auth', 'auth.sa']
kwargs = { 't': '1d', 'name': 'tanmingyang01' }

test(*args, **kwargs)
```

## 来自你的消息:
PYTHONPATH 有什么用

PYTHONPATH 是一个环境变量，用于指定Python解释器在导入模块（模块搜索路径）时需要搜索的路径列表。

当你运行 Python 解释器并导入一个模块时，Python 会按照以下顺序搜索模块：

1. 当前文件夹（也就是脚本所在的文件夹）。
2. 然后是 Python 内置模块（比如 os、sys 等）。
3. 然后是 PYTHONPATH 环境变量中所包含的目录。
4. 最后是 Python 安装目录下的 site-packages 目录及其下面的目录。

所以，使用 PYTHONPATH 环境变量可以方便地将自己编写的模块添加到 Python 的模块搜索路径中，从而可以在运行 Python 脚本时，导入这些模块而不会出现 ImportError 的错误。

假设你的自定义模块、包存放在 /home/user/my_modules 下，你可以在终端中设置 PYTHONPATH 环境变量：

```
export PYTHONPATH=/home/user/my_modules:$PYTHONPATH
```

又例如你的配置文件目录如下：conf/config.py，你希望在你的文件中使用 from conf import config 引入配置，你可以：

```
export PYTHONPATH=$PYTHONPATH:./conf
```

也可以在程序中设置 PYTHONPATH 环境变量。例如：

```python
import os
import sys

# 将 /home/user/my_modules 添加到模块搜索路径中
user_paths = os.path.expanduser('~/.local/lib/python3.8/site-packages')
sys.path.insert(0, user_paths + '/home/user/my_modules')

# 导入 my_module 模块
import my_module
```

总之，PYTHONPATH 环境变量是一个很重要的工具，用于扩展 Python 的模块搜索路径，方便我们在编写 Python 代码时导入自己编写的模块。

## *args, **kwargs
```python
def print_func(x, *args, **kwargs):
    print(x)
    print(args)
    print(kwargs)

print_func(1, 2, 3, 4, y=1, a=2, b=3, c=4)
```

```
1
(2, 3, 4)
{'y': 1, 'a': 2, 'b': 3, 'c': 4}
```

### yield
当Python函数中包含yield语句时，它被称为生成器函数。生成器函数是一种特殊类型的函数，每次执行yield语句时，它会返回一个值并保留当前状态，允许程序从上次离开的地方继续执行。这使得我们可以逐步生成结果而不需要一次性计算所有内容，从而节省了内存和时间。

以下是一个使用yield的简单示例函数，用于生成斐波那契数列：

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
```

在以上代码中，`fibonacci`是一个生成器函数。通过使用`yield`语句，在每次循环迭代中将`a`值作为产生的下一个元素返回给调用者，并更新`a`和`b`的值以便下次迭代。该函数可以无限地生成斐波那契数列。

要使用这个生成器函数，我们可以像调用普通函数一样进行迭代：

```python
fib = fibonacci()
for i in range(10):
    print(next(fib))
```

输出结果：
```
0
1
1
2
3
5
8
13
21
34
```

在上面的示例中，我们使用`next()`函数来获取生成器函数中的下一个元素。每次调用`next(fib)`时，函数将运行到`yield`语句处并返回当前的`a`值，然后暂停等待下一次调用。

而且，你可以通过将生成器函数放入for循环中来遍历生成器的内容，而不需要使用`next()`函数逐个获取生成器的值。每次迭代循环时，它都会自动调用`next()`方法，并返回生成器的下一个值，直到生成器耗尽为止。

以下是一个示例代码，它会迭代输出斐波那契数列前10个数字：

```python
def fib():
    a, b = 0, 1
    for _ in range(10):
        yield a
        a, b = b, a + b

for num in fib():
    print(num)
```

这样，当你运行这段代码时，将在控制台上依次输出斐波那契数列的前10个数字：0、1、1、2、3、5、8、13、21、34。

生成器函数非常有用，尤其是在处理大量数据或无法全部加载到内存中的情况下。通过仅在需要时逐步生成结果，我们可以降低对内存的消耗并提高效率。

### pdb调试
pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。https://docs.python.org/zh-cn/3/library/pdb.html

### __init__.py
标识这个目录是一个包

### __main__.py
标识这个文件是主程序

### __enter__、__exit__
在 Python 中，__enter__ 和 __exit__ 是两个特殊方法，它们通常被用来定义一个对象的上下文管理协议—也就是所谓的“with 语句”支持。这种机制也被称为上下文管理器。

with方法会触发 __enter__ 方法，with中代码执行完后会触发 __exit__ 方法