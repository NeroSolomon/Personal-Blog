## 题目：统计封闭岛屿的数量

给定一个由 `0`（陆地）和 `1`（水）组成的 `m x n` 二维矩阵，定义**封闭岛屿**为完全被水包围的陆地区域（即不与矩阵边界相连的陆地）。请编写一个算法，统计矩阵中封闭岛屿的数量。

**示例 1：**  
输入：  
```
grid = [
  [1,1,1,1,1],
  [1,0,0,1,1],
  [1,1,0,1,1],
  [1,1,1,1,1]
]
```
输出：`0`  
解释：所有陆地均与边界相连，没有封闭岛屿。

---

**示例 2：**  
输入：  
```
grid = [
  [1,1,1,1,1],
  [1,0,0,0,1],
  [1,0,1,0,1],
  [1,0,0,0,1],
  [1,1,1,1,1]
]
```
输出：`1`  
解释：中心有一个封闭岛屿。

---

### **要求**
1. 使用深度优先搜索（DFS）实现。
2. 时间复杂度尽可能低。

---

### **提示**
1. 封闭岛屿的判定条件是：所有陆地位于矩阵内部，且不与边界直接或间接相连。
2. 可以先排除所有与边界相连的陆地，再统计剩余陆地的连通分量数量。

---

### **参考答案思路**
1. **排除边界相连的陆地**：  
   遍历矩阵的四条边界，如果发现陆地（`0`），用DFS将其所有相连的陆地标记为“已访问”（例如标记为 `2`）。
2. **统计内部封闭岛屿**：  
   遍历整个矩阵，对未被访问的陆地（仍为 `0`）进行DFS，每次DFS计数加1。
3. **时间复杂度**：`O(m*n)`，每个单元格最多被访问两次。

---

**代码框架（Python）**
```python
def closed_island(grid):
    if not grid:
        return 0

    m, n = len(grid), len(grid[0])
    count = 0

    def dfs(x, y):
        if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0:
            return
        grid[x][y] = 2  # 标记为已访问
        dfs(x+1, y)
        dfs(x-1, y)
        dfs(x, y+1)
        dfs(x, y-1)

    # 步骤1：排除边界相连的陆地
    for i in range(m):
        for j in range(n):
            if (i == 0 or i == m-1 or j == 0 or j == n-1) and grid[i][j] == 0:
                dfs(i, j)

    # 步骤2：统计封闭岛屿数量
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 0:
                dfs(i, j)
                count += 1

    return count
```

---

### **考察点**
1. **DFS的应用能力**：能否正确实现DFS遍历，并处理边界条件。
2. **问题分解**：能否将问题拆分为“排除边界陆地”和“统计内部岛屿”两个步骤。
3. **代码健壮性**：是否处理空矩阵、矩阵边界等特殊情况。