在 LeetCode 中，算法题的解题模式大致可以分为以下几类：

### 1. **暴力法**
   - **特点**：直接模拟问题，通常时间复杂度较高。
   - **适用场景**：问题规模较小或作为其他优化方法的基础。

### 2. **双指针**
   - **特点**：使用两个指针在数组或链表中遍历，通常用于优化时间复杂度。
   - **适用场景**：有序数组、链表相关问题，如两数之和、合并有序数组等。

#### 题目：两数之和 II - 输入有序数组

**题目描述**：
给定一个已按照 **升序排列** 的整数数组 `numbers`，请你从数组中找出两个数，使得它们的和等于目标数 `target`。假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

返回这两个数的下标值（下标从 1 开始）。

**示例**：
```javascript
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1, 2]
解释: 2 + 7 = 9，因此返回下标 [1, 2]。
```

#### 解题思路：

1. **初始化两个指针**：
   - `left` 指针指向数组的起始位置（下标 0）。
   - `right` 指针指向数组的末尾位置（下标 `numbers.length - 1`）。

2. **循环条件**：
   - 当 `left < right` 时，执行循环。

3. **计算两数之和**：
   - 计算 `numbers[left] + numbers[right]`。
   - 如果和等于 `target`，返回 `[left + 1, right + 1]`（因为题目要求下标从 1 开始）。
   - 如果和小于 `target`，说明需要更大的数，将 `left` 指针右移（`left++`）。
   - 如果和大于 `target`，说明需要更小的数，将 `right` 指针左移（`right--`）。

4. **边界条件**：
   - 题目保证有唯一解，因此不需要额外处理无解的情况。


#### 代码实现

```javascript
function twoSum(numbers, target) {
    let left = 0; // 左指针
    let right = numbers.length - 1; // 右指针

    while (left < right) {
        const sum = numbers[left] + numbers[right]; // 计算两数之和
        if (sum === target) {
            return [left + 1, right + 1]; // 返回下标（从 1 开始）
        } else if (sum < target) {
            left++; // 和太小，左指针右移
        } else {
            right--; // 和太大，右指针左移
        }
    }

    // 题目保证有解，这里不会执行
    return [-1, -1];
}

// 测试用例
const numbers = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(numbers, target)); // 输出: [1, 2]
```

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。双指针最多遍历数组一次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。


#### 总结

双指针是一种高效的解题方法，特别适用于 **有序数组** 或 **链表** 相关的问题。通过左右指针的移动，可以快速缩小搜索范围，从而降低时间复杂度。


### 3. **滑动窗口**
   - **特点**：通过维护一个窗口来解决问题，常用于子数组或子字符串问题。
   - **适用场景**：连续子数组、子字符串的最值问题，如最小覆盖子串、最长无重复字符子串等。

#### 题目：无重复字符的最长子串

**题目描述**：
给定一个字符串 `s`，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例**：
```javascript
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 解题思路：滑动窗口

1. **滑动窗口的定义**：
   - 滑动窗口是一个动态的区间，用两个指针表示：`left` 和 `right`。
   - `left` 指针表示窗口的左边界，`right` 指针表示窗口的右边界。

2. **核心思想**：
   - 通过移动 `right` 指针扩展窗口，将字符加入窗口。
   - 如果发现当前字符已经存在于窗口中，则移动 `left` 指针缩小窗口，直到窗口中不再有重复字符。
   - 在每次扩展窗口时，更新最长子串的长度。

3. **数据结构**：
   - 使用一个哈希集合（`Set`）来存储窗口中的字符，方便快速判断字符是否重复。

4. **算法流程**：
   - 初始化 `left` 和 `right` 指针为 0，初始化最大长度 `maxLen` 为 0。
   - 遍历字符串，移动 `right` 指针：
     - 如果当前字符不在集合中，将其加入集合，并更新 `maxLen`。
     - 如果当前字符在集合中，移动 `left` 指针，并从集合中移除 `s[left]`，直到当前字符不再重复。
   - 返回 `maxLen`。

#### 代码实现

```javascript
function lengthOfLongestSubstring(s) {
    let left = 0; // 滑动窗口的左边界
    let right = 0; // 滑动窗口的右边界
    let maxLen = 0; // 记录最大长度
    const charSet = new Set(); // 用于存储窗口中的字符

    while (right < s.length) {
        const currentChar = s[right]; // 当前字符
        if (!charSet.has(currentChar)) {
            // 如果字符不在集合中，加入集合并扩展右边界
            charSet.add(currentChar);
            maxLen = Math.max(maxLen, right - left + 1); // 更新最大长度
            right++; // 右指针右移
        } else {
            // 如果字符在集合中，移动左边界并移除字符
            charSet.delete(s[left]);
            left++; // 左指针右移
        }
    }

    return maxLen;
}

// 测试用例
const s = "abcabcbb";
console.log(lengthOfLongestSubstring(s)); // 输出: 3
```

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是字符串的长度。每个字符最多被访问两次（`left` 和 `right` 各一次）。
- **空间复杂度**：`O(min(m, n))`，其中 `m` 是字符集的大小（ASCII 字符集为 128）。在最坏情况下，集合中会存储所有字符。


#### 总结

滑动窗口是一种非常实用的解题技巧，特别适用于 **子数组** 或 **子字符串** 相关的问题。通过动态调整窗口的大小，可以高效地解决问题，同时保持较低的时间复杂度。

### 4. **二分查找**
   - **特点**：通过不断缩小搜索范围来快速找到目标，时间复杂度通常为 O(log n)。
   - **适用场景**：有序数组中的查找问题，如搜索插入位置、寻找峰值等。

### 5. **深度优先搜索（DFS）**
   - **特点**：通过递归或栈实现，用于遍历或搜索树、图等结构。
   - **适用场景**：组合、排列、路径搜索等问题，如二叉树遍历、岛屿数量等。

### 6. **广度优先搜索（BFS）**
   - **特点**：通过队列实现，用于层次遍历或最短路径问题。
   - **适用场景**：最短路径、层次遍历等问题，如二叉树层次遍历、单词接龙等。

### 7. **动态规划（DP）**
   - **特点**：通过保存子问题的解来避免重复计算，通常用于优化时间复杂度。
   - **适用场景**：最优化问题、计数问题等，如最长递增子序列、背包问题等。

### 8. **贪心算法**
   - **特点**：每一步选择当前最优解，期望最终得到全局最优解。
   - **适用场景**：最优化问题，如区间调度、分糖果等。

### 9. **回溯法**
   - **特点**：通过递归尝试所有可能的解，并在不满足条件时回退。
   - **适用场景**：组合、排列、子集等问题，如全排列、N 皇后问题等。

### 10. **分治法**
   - **特点**：将问题分解为多个子问题，分别解决后再合并结果。
   - **适用场景**：归并排序、快速排序、最大子数组等问题。

### 11. **位运算**
   - **特点**：利用位操作来高效解决问题。
   - **适用场景**：二进制相关问题，如汉明距离、只出现一次的数字等。

### 12. **并查集（Union-Find）**
   - **特点**：用于处理不相交集合的合并与查询问题。
   - **适用场景**：连通性问题，如朋友圈、岛屿数量等。

### 13. **前缀和与差分**
   - **特点**：通过预处理数组来快速计算区间和或区间更新。
   - **适用场景**：区间求和、区间更新等问题，如子数组和为 K、航班预订统计等。

### 14. **单调栈/队列**
   - **特点**：利用栈或队列维护单调性，用于解决特定问题。
   - **适用场景**：下一个更大元素、滑动窗口最大值等问题。

### 15. **图算法**
   - **特点**：涉及图的遍历、最短路径、拓扑排序等。
   - **适用场景**：图的遍历、最短路径、拓扑排序等问题，如课程表、网络延迟时间等。

### 16. **数学方法**
   - **特点**：利用数学公式或性质解决问题。
   - **适用场景**：质数、排列组合、数论等问题，如计数质数、排列序列等。

### 17. **模拟法**
   - **特点**：按照题目要求逐步模拟过程。
   - **适用场景**：复杂的流程模拟问题，如螺旋矩阵、旋转图像等。

### 总结
这些解题模式并非孤立，实际解题时常常需要结合多种方法。掌握这些模式有助于快速识别问题类型并选择合适的算法。