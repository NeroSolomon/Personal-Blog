在 LeetCode 中，算法题的解题模式大致可以分为以下几类：

### 1. **暴力法**
   - **特点**：直接模拟问题，通常时间复杂度较高。
   - **适用场景**：问题规模较小或作为其他优化方法的基础。

### 2. **双指针**
   - **特点**：使用两个指针在数组或链表中遍历，通常用于优化时间复杂度。
   - **适用场景**：有序数组、链表相关问题，如两数之和、合并有序数组等。

#### 题目：两数之和 II - 输入有序数组

**题目描述**：
给定一个已按照 **升序排列** 的整数数组 `numbers`，请你从数组中找出两个数，使得它们的和等于目标数 `target`。假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

返回这两个数的下标值（下标从 1 开始）。

**示例**：
```javascript
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1, 2]
解释: 2 + 7 = 9，因此返回下标 [1, 2]。
```

#### 解题思路：

1. **初始化两个指针**：
   - `left` 指针指向数组的起始位置（下标 0）。
   - `right` 指针指向数组的末尾位置（下标 `numbers.length - 1`）。

2. **循环条件**：
   - 当 `left < right` 时，执行循环。

3. **计算两数之和**：
   - 计算 `numbers[left] + numbers[right]`。
   - 如果和等于 `target`，返回 `[left + 1, right + 1]`（因为题目要求下标从 1 开始）。
   - 如果和小于 `target`，说明需要更大的数，将 `left` 指针右移（`left++`）。
   - 如果和大于 `target`，说明需要更小的数，将 `right` 指针左移（`right--`）。

4. **边界条件**：
   - 题目保证有唯一解，因此不需要额外处理无解的情况。


#### 代码实现

```javascript
function twoSum(numbers, target) {
    let left = 0; // 左指针
    let right = numbers.length - 1; // 右指针

    while (left < right) {
        const sum = numbers[left] + numbers[right]; // 计算两数之和
        if (sum === target) {
            return [left + 1, right + 1]; // 返回下标（从 1 开始）
        } else if (sum < target) {
            left++; // 和太小，左指针右移
        } else {
            right--; // 和太大，右指针左移
        }
    }

    // 题目保证有解，这里不会执行
    return [-1, -1];
}

// 测试用例
const numbers = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(numbers, target)); // 输出: [1, 2]
```

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。双指针最多遍历数组一次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。


#### 总结

双指针是一种高效的解题方法，特别适用于 **有序数组** 或 **链表** 相关的问题。通过左右指针的移动，可以快速缩小搜索范围，从而降低时间复杂度。


### 3. **滑动窗口**
   - **特点**：通过维护一个窗口来解决问题，常用于子数组或子字符串问题。
   - **适用场景**：连续子数组、子字符串的最值问题，如最小覆盖子串、最长无重复字符子串等。

#### 题目：无重复字符的最长子串

**题目描述**：
给定一个字符串 `s`，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例**：
```javascript
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 解题思路：滑动窗口

1. **滑动窗口的定义**：
   - 滑动窗口是一个动态的区间，用两个指针表示：`left` 和 `right`。
   - `left` 指针表示窗口的左边界，`right` 指针表示窗口的右边界。

2. **核心思想**：
   - 通过移动 `right` 指针扩展窗口，将字符加入窗口。
   - 如果发现当前字符已经存在于窗口中，则移动 `left` 指针缩小窗口，直到窗口中不再有重复字符。
   - 在每次扩展窗口时，更新最长子串的长度。

3. **数据结构**：
   - 使用一个哈希集合（`Set`）来存储窗口中的字符，方便快速判断字符是否重复。

4. **算法流程**：
   - 初始化 `left` 和 `right` 指针为 0，初始化最大长度 `maxLen` 为 0。
   - 遍历字符串，移动 `right` 指针：
     - 如果当前字符不在集合中，将其加入集合，并更新 `maxLen`。
     - 如果当前字符在集合中，移动 `left` 指针，并从集合中移除 `s[left]`，直到当前字符不再重复。
   - 返回 `maxLen`。

#### 代码实现

```javascript
function lengthOfLongestSubstring(s) {
    let left = 0; // 滑动窗口的左边界
    let right = 0; // 滑动窗口的右边界
    let maxLen = 0; // 记录最大长度
    const charSet = new Set(); // 用于存储窗口中的字符

    while (right < s.length) {
        const currentChar = s[right]; // 当前字符
        if (!charSet.has(currentChar)) {
            // 如果字符不在集合中，加入集合并扩展右边界
            charSet.add(currentChar);
            maxLen = Math.max(maxLen, right - left + 1); // 更新最大长度
            right++; // 右指针右移
        } else {
            // 如果字符在集合中，移动左边界并移除字符
            charSet.delete(s[left]);
            left++; // 左指针右移
        }
    }

    return maxLen;
}

// 测试用例
const s = "abcabcbb";
console.log(lengthOfLongestSubstring(s)); // 输出: 3
```

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是字符串的长度。每个字符最多被访问两次（`left` 和 `right` 各一次）。
- **空间复杂度**：`O(min(m, n))`，其中 `m` 是字符集的大小（ASCII 字符集为 128）。在最坏情况下，集合中会存储所有字符。


#### 总结

滑动窗口是一种非常实用的解题技巧，特别适用于 **子数组** 或 **子字符串** 相关的问题。通过动态调整窗口的大小，可以高效地解决问题，同时保持较低的时间复杂度。

### 4. **二分查找**
   - **特点**：通过不断缩小搜索范围来快速找到目标，时间复杂度通常为 O(log n)。
   - **适用场景**：有序数组中的查找问题，如搜索插入位置、寻找峰值等。
#### 题目：搜索插入位置

**题目描述**：
给定一个排序数组 `nums` 和一个目标值 `target`，请你在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**示例**：
```javascript
输入: nums = [1, 3, 5, 6], target = 5
输出: 2

输入: nums = [1, 3, 5, 6], target = 2
输出: 1
```

---

#### 解题思路：二分查找

1. **二分查找的核心思想**：
   - 在有序数组中，通过不断缩小搜索范围来快速找到目标值或插入位置。
   - 每次将搜索区间分为两部分，通过比较中间元素与目标值来决定下一步搜索的方向。

2. **算法流程**：
   - 初始化左指针 `left` 为 0，右指针 `right` 为 `nums.length - 1`。
   - 当 `left <= right` 时，执行循环：
     - 计算中间位置 `mid = Math.floor((left + right) / 2)`。
     - 如果 `nums[mid] === target`，直接返回 `mid`。
     - 如果 `nums[mid] < target`，说明目标值在右半部分，将 `left` 更新为 `mid + 1`。
     - 如果 `nums[mid] > target`，说明目标值在左半部分，将 `right` 更新为 `mid - 1`。
   - 如果循环结束仍未找到目标值，则返回 `left`，即目标值应该插入的位置。

---

#### 代码实现

```javascript
function searchInsert(nums, target) {
    let left = 0; // 左指针
    let right = nums.length - 1; // 右指针

    while (left <= right) {
        const mid = Math.floor((left + right) / 2); // 计算中间位置
        if (nums[mid] === target) {
            return mid; // 找到目标值，返回索引
        } else if (nums[mid] < target) {
            left = mid + 1; // 目标值在右半部分
        } else {
            right = mid - 1; // 目标值在左半部分
        }
    }

    // 如果未找到目标值，返回插入位置
    return left;
}

// 测试用例
const nums = [1, 3, 5, 6];
const target1 = 5;
const target2 = 2;
console.log(searchInsert(nums, target1)); // 输出: 2
console.log(searchInsert(nums, target2)); // 输出: 1
```

---

#### 复杂度分析

- **时间复杂度**：`O(log n)`，其中 `n` 是数组的长度。每次搜索范围缩小一半。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。

---

#### 总结

二分查找是一种高效的搜索算法，特别适用于 **有序数组** 中的查找问题。通过不断缩小搜索范围，可以快速定位目标值或插入位置，时间复杂度为 `O(log n)`，远优于线性搜索的 `O(n)`。

### 5. **深度优先搜索（DFS）**
   - **特点**：通过递归或栈实现，用于遍历或搜索树、图等结构。
   - **适用场景**：组合、排列、路径搜索等问题，如二叉树遍历、岛屿数量等。

### 6. **广度优先搜索（BFS）**
   - **特点**：通过队列实现，用于层次遍历或最短路径问题。
   - **适用场景**：最短路径、层次遍历等问题，如二叉树层次遍历、单词接龙等。

### 7. **动态规划（DP）**
   - **特点**：通过保存子问题的解来避免重复计算，通常用于优化时间复杂度。
   - **适用场景**：最优化问题、计数问题等，如最长递增子序列、背包问题等。

#### 题目：爬楼梯

**题目描述**：
假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？

**示例**：
```javascript
输入: n = 2
输出: 2
解释: 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

输入: n = 3
输出: 3
解释: 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

---

#### 解题思路：动态规划

1. **问题分析**：
   - 爬到第 `n` 阶楼梯的方法数，可以分解为以下两种情况的和：

      最后一步爬 1 阶：

      如果最后一步爬 1 阶，那么在此之前，你已经爬到了第 n-1 阶。

      因此，这种情况下的方法数等于 爬到第 n-1 阶的方法数。

      最后一步爬 2 阶：

      如果最后一步爬 2 阶，那么在此之前，你已经爬到了第 n-2 阶。

      因此，这种情况下的方法数等于 爬到第 n-2 阶的方法数。

   - 这实际上是一个 **斐波那契数列** 问题。

2. **动态规划定义**：
   - 设 `dp[i]` 表示爬到第 `i` 阶楼梯的方法数。
   - 状态转移方程：`dp[i] = dp[i-1] + dp[i-2]`。

3. **初始条件**：
   - `dp[0] = 1`：爬到第 0 阶（地面）只有一种方法（不动）。
   - `dp[1] = 1`：爬到第 1 阶只有一种方法（爬 1 阶）。

4. **优化空间复杂度**：
   - 由于 `dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]`，可以用两个变量代替整个 `dp` 数组，将空间复杂度优化为 `O(1)`。

---

#### 代码实现

##### 方法 1：动态规划（空间复杂度 O(n)）
```javascript
function climbStairs(n) {
    if (n === 0 || n === 1) return 1;

    const dp = new Array(n + 1).fill(0); // 初始化 dp 数组
    dp[0] = 1; // 初始条件
    dp[1] = 1; // 初始条件

    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]; // 状态转移方程
    }

    return dp[n];
}

// 测试用例
console.log(climbStairs(2)); // 输出: 2
console.log(climbStairs(3)); // 输出: 3
console.log(climbStairs(4)); // 输出: 5
```

##### 方法 2：动态规划（空间复杂度 O(1)）
```javascript
function climbStairs(n) {
    if (n === 0 || n === 1) return 1;

    let prev1 = 1; // 相当于 dp[i-1]
    let prev2 = 1; // 相当于 dp[i-2]

    for (let i = 2; i <= n; i++) {
        const current = prev1 + prev2; // 计算 dp[i]
        prev2 = prev1; // 更新 dp[i-2]
        prev1 = current; // 更新 dp[i-1]
    }

    return prev1;
}

// 测试用例
console.log(climbStairs(2)); // 输出: 2
console.log(climbStairs(3)); // 输出: 3
console.log(climbStairs(4)); // 输出: 5
```

---

#### 复杂度分析

- **时间复杂度**：`O(n)`，需要遍历从 2 到 `n` 的所有台阶。
- **空间复杂度**：
  - 方法 1：`O(n)`，需要存储 `dp` 数组。
  - 方法 2：`O(1)`，只使用了常数级别的额外空间。

---

#### 总结

动态规划是一种将复杂问题分解为子问题的解题方法，通过保存子问题的解来避免重复计算。在本题中，通过定义状态转移方程和初始条件，可以高效地解决问题。优化空间复杂度后，动态规划的实用性更强。

### 8. **贪心算法**
   - **特点**：每一步选择当前最优解，期望最终得到全局最优解。
   - **适用场景**：最优化问题，如区间调度、分糖果等。

#### 题目：分发饼干

**题目描述**：
假设你是一位很棒的家长，想要给你的孩子们一些饼干。每个孩子最多只能给一块饼干。对于每个孩子 `i`，有一个胃口值 `g[i]`，表示他能接受的最小饼干尺寸；对于每块饼干 `j`，有一个尺寸 `s[j]`。如果 `s[j] >= g[i]`，你可以将这块饼干 `j` 分配给孩子 `i`。你的目标是尽可能满足更多的孩子，并输出最多可以满足的孩子数量。

**示例**：
```javascript
输入: g = [1, 2, 3], s = [1, 1]
输出: 1
解释: 
你有三个孩子和两块饼干，孩子的胃口值分别是 1, 2, 3。
你可以将尺寸为 1 的饼干分配给胃口值为 1 的孩子，这样只能满足一个孩子。
```

---

#### 解题思路：贪心算法

1. **贪心策略**：
   - 将孩子的胃口值 `g` 和饼干的尺寸 `s` 分别排序。
   - 从小到大遍历饼干，尝试将最小的饼干分配给胃口最小的孩子。
   - 如果当前饼干可以满足当前孩子，则分配，并移动到下一个孩子和下一个饼干。
   - 如果当前饼干不能满足当前孩子，则尝试用更大的饼干满足当前孩子。

2. **核心思想**：
   - 优先用最小的饼干满足胃口最小的孩子，这样可以最大化满足孩子的数量。

3. **算法流程**：
   - 排序 `g` 和 `s`。
   - 初始化两个指针 `i` 和 `j`，分别指向 `g` 和 `s` 的起始位置。
   - 遍历饼干和孩子：
     - 如果当前饼干 `s[j]` 可以满足当前孩子 `g[i]`，则计数加 1，并移动两个指针。
     - 否则，只移动饼干指针 `j`，尝试用更大的饼干满足当前孩子。
   - 返回满足的孩子数量。

---

#### 代码实现

```javascript
function findContentChildren(g, s) {
    // 将孩子的胃口值和饼干的尺寸排序
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);

    let i = 0; // 孩子指针
    let j = 0; // 饼干指针
    let count = 0; // 满足的孩子数量

    while (i < g.length && j < s.length) {
        if (s[j] >= g[i]) {
            // 如果当前饼干可以满足当前孩子
            count++; // 满足的孩子数量加 1
            i++; // 移动到下一个孩子
        }
        j++; // 尝试用下一个饼干
    }

    return count;
}

// 测试用例
const g = [1, 2, 3];
const s = [1, 1];
console.log(findContentChildren(g, s)); // 输出: 1
```

---

#### 复杂度分析

- **时间复杂度**：`O(n log n + m log m)`，其中 `n` 是孩子数量，`m` 是饼干数量。排序的时间复杂度是 `O(n log n + m log m)`，遍历的时间复杂度是 `O(n + m)`。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。

---

#### 总结

贪心算法的核心思想是 **每一步都选择当前最优的解**，从而希望最终得到全局最优解。在本题中，通过优先用最小的饼干满足胃口最小的孩子，可以最大化满足孩子的数量。贪心算法通常适用于问题具有 **最优子结构** 和 **贪心选择性质** 的情况。

### 9. **回溯法**
   - **特点**：通过递归尝试所有可能的解，并在不满足条件时回退。
   - **适用场景**：组合、排列、子集等问题，如全排列、N 皇后问题等。

#### 题目：全排列

**题目描述**：
给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。

**示例**：
```javascript
输入: nums = [1, 2, 3]
输出: [
  [1, 2, 3],
  [1, 3, 2],
  [2, 1, 3],
  [2, 3, 1],
  [3, 1, 2],
  [3, 2, 1]
]
```

---

#### 解题思路：回溯法

1. **回溯法的核心思想**：
   - 通过递归尝试所有可能的解，并在每一步选择后回退（撤销选择），继续尝试其他可能性。
   - 适用于需要遍历所有可能解的问题，如排列、组合、子集等。

2. **全排列问题的特点**：
   - 每个排列的长度等于数组的长度。
   - 每个元素只能使用一次。

3. **算法流程**：
   - 定义一个递归函数 `backtrack`，用于生成排列。
   - 使用一个数组 `path` 记录当前的排列。
   - 使用一个数组 `used` 记录哪些元素已经被使用过。
   - 遍历数组中的每个元素：
     - 如果当前元素未被使用，则将其加入 `path`，并标记为已使用。
     - 递归调用 `backtrack`，继续生成下一个位置的元素。
     - 在递归返回后，撤销选择（将当前元素从 `path` 中移除，并标记为未使用）。
   - 当 `path` 的长度等于 `nums` 的长度时，说明找到一个排列，将其加入结果集。

---

#### 代码实现

```javascript
function permute(nums) {
    const result = []; // 存储所有排列的结果
    const path = []; // 当前路径（当前排列）
    const used = new Array(nums.length).fill(false); // 记录元素是否被使用过

    // 定义回溯函数
    function backtrack() {
        if (path.length === nums.length) {
            // 如果当前路径的长度等于数组长度，说明找到一个排列
            result.push([...path]); // 将当前路径加入结果集
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            if (!used[i]) {
                // 如果当前元素未被使用
                path.push(nums[i]); // 将当前元素加入路径
                used[i] = true; // 标记为已使用
                backtrack(); // 递归生成下一个位置的元素
                path.pop(); // 撤销选择（回溯）
                used[i] = false; // 标记为未使用
            }
        }
    }

    backtrack(); // 开始回溯
    return result;
}

// 测试用例
const nums = [1, 2, 3];
console.log(permute(nums));
// 输出:
// [
//   [1, 2, 3],
//   [1, 3, 2],
//   [2, 1, 3],
//   [2, 3, 1],
//   [3, 1, 2],
//   [3, 2, 1]
// ]
```

---

#### 复杂度分析

- **时间复杂度**：`O(n * n!)`，其中 `n` 是数组的长度。全排列的数量是 `n!`，每个排列需要 `O(n)` 的时间来生成。
- **空间复杂度**：`O(n)`，递归调用栈的深度最多为 `n`，且需要额外的空间存储 `path` 和 `used`。

---

#### 总结

回溯法是一种通过递归遍历所有可能解的方法，适用于需要穷举所有可能性的问题。在全排列问题中，通过回溯法可以高效地生成所有排列。关键在于：
1. **选择**：在每一步选择一个未被使用的元素加入当前路径。
2. **递归**：继续生成下一个位置的元素。
3. **撤销选择**：在递归返回后，撤销当前选择，尝试其他可能性。

回溯法是解决排列、组合、子集等问题的经典方法。

### 10. **分治法**
   - **特点**：将问题分解为多个子问题，分别解决后再合并结果。
   - **适用场景**：归并排序、快速排序、最大子数组等问题。
   分治法和动态规划的主要区别如下：

   **子问题的关系**

   分治法：子问题之间相互独立，不存在重叠

   动态规划：子问题之间有重叠部分，存在重复计算

   **解决方式**

   分治法：自顶向下，递归求解

   动态规划：自底向上，迭代求解，通常使用表格存储中间结果

   **效率**

   分治法：可能存在重复计算，时间复杂度较高

   动态规划：通过存储中间结果避免重复计算，效率更高

   **适用场景**

   分治法：适用于子问题相互独立的场景，如归并排序、快速排序

   动态规划：适用于具有重叠子问题和最优子结构的场景，如背包问题、最长公共子序列

   **实现方式**

   分治法：主要通过递归实现

   动态规划：可以用递归(记忆化搜索)或迭代实现

#### 题目：归并排序

**题目描述**：
给定一个整数数组 `nums`，将其按升序排序。

**示例**：
```javascript
输入: nums = [5, 2, 3, 1]
输出: [1, 2, 3, 5]
```

---

#### 解题思路：分治法

1. **分治法的核心思想**：
   - 将问题分解为多个子问题，分别解决后再合并结果。
   - 适用于可以递归分解的问题，如排序、查找、计算等。

2. **归并排序的特点**：
   - 将数组分成两半，分别对左半部分和右半部分进行排序，然后将两个有序数组合并成一个有序数组。
   - 递归地将数组分解，直到子数组的长度为 1（天然有序），然后逐步合并。

3. **算法流程**：
   - **分解**：将数组从中间分成两半。
   - **解决**：递归地对左半部分和右半部分进行排序。
   - **合并**：将两个有序的子数组合并成一个有序数组。

---

#### 代码实现

```javascript
function mergeSort(nums) {
    // 如果数组长度小于等于 1，直接返回
    if (nums.length <= 1) {
        return nums;
    }

    // 分解：将数组分成两半
    const mid = Math.floor(nums.length / 2);
    const left = nums.slice(0, mid); // 左半部分
    const right = nums.slice(mid); // 右半部分

    // 解决：递归地对左半部分和右半部分进行排序
    const sortedLeft = mergeSort(left);
    const sortedRight = mergeSort(right);

    // 合并：将两个有序数组合并成一个有序数组
    return merge(sortedLeft, sortedRight);
}

// 合并两个有序数组
function merge(left, right) {
    const result = []; // 存储合并后的结果
    let i = 0; // 左半部分的指针
    let j = 0; // 右半部分的指针

    // 比较两个数组的元素，按顺序加入结果数组
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }

    // 将剩余的元素加入结果数组
    while (i < left.length) {
        result.push(left[i]);
        i++;
    }
    while (j < right.length) {
        result.push(right[j]);
        j++;
    }

    return result;
}

// 测试用例
const nums = [5, 2, 3, 1];
console.log(mergeSort(nums)); // 输出: [1, 2, 3, 5]
```

---

#### 复杂度分析

- **时间复杂度**：`O(n log n)`，其中 `n` 是数组的长度。
  - 分解：每次将数组分成两半，需要 `O(log n)` 层递归。
  - 合并：每层递归需要 `O(n)` 的时间来合并两个有序数组。
- **空间复杂度**：`O(n)`，需要额外的空间存储合并后的数组。

---

#### 总结

分治法是一种将问题分解为子问题并递归解决的算法设计思想。在归并排序中：
1. **分解**：将数组分成两半。
2. **解决**：递归地对左半部分和右半部分进行排序。
3. **合并**：将两个有序数组合并成一个有序数组。

归并排序的时间复杂度为 `O(n log n)`，是一种稳定的排序算法，适用于大规模数据的排序。

### 11. **位运算**
   - **特点**：利用位操作来高效解决问题。
   - **适用场景**：二进制相关问题，如汉明距离、只出现一次的数字等。

#### 题目：只出现一次的数字

**题目描述**：
给定一个 **非空** 整数数组 `nums`，其中除了某个元素只出现一次以外，其余每个元素均出现两次。请找出那个只出现一次的元素。

**示例**：
```javascript
输入: nums = [2, 2, 1]
输出: 1

输入: nums = [4, 1, 2, 1, 2]
输出: 4
```

---

#### 解题思路：位运算（异或运算）

1. **异或运算的性质**：
   - 任何数和 `0` 做异或运算，结果仍然是原来的数：`a ^ 0 = a`。
   - 任何数和其自身做异或运算，结果是 `0`：`a ^ a = 0`。
   - 异或运算满足交换律和结合律：`a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`。

2. **核心思想**：
   - 将数组中的所有元素进行异或运算，出现两次的元素会相互抵消（结果为 `0`），最终剩下的就是只出现一次的元素。

3. **算法流程**：
   - 初始化一个变量 `result` 为 `0`。
   - 遍历数组中的每个元素，将其与 `result` 进行异或运算。
   - 最终 `result` 的值就是只出现一次的元素。

---

#### 代码实现

```javascript
function singleNumber(nums) {
    let result = 0; // 初始化结果为 0

    // 遍历数组，进行异或运算
    for (const num of nums) {
        result ^= num; // 异或运算
    }

    return result; // 返回结果
}

// 测试用例
const nums1 = [2, 2, 1];
const nums2 = [4, 1, 2, 1, 2];
console.log(singleNumber(nums1)); // 输出: 1
console.log(singleNumber(nums2)); // 输出: 4
```

---

#### 复杂度分析

- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。只需要遍历数组一次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。

---

#### 总结

位运算是一种高效的解题方法，特别适用于处理二进制相关的问题。在本题中，通过异或运算的性质，可以快速找到只出现一次的元素：
1. **异或运算**：利用 `a ^ a = 0` 和 `a ^ 0 = a` 的性质，抵消出现两次的元素。
2. **高效性**：时间复杂度为 `O(n)`，空间复杂度为 `O(1)`，是一种非常优雅的解法。

位运算在算法竞赛和实际开发中都有广泛应用，掌握其性质和使用场景可以大幅提升解题效率。

### 12. **并查集（Union-Find）**
   - **特点**：用于处理不相交集合的合并与查询问题。
   - **适用场景**：连通性（环）问题，如朋友圈、岛屿数量等。TODO：研究下如何用这个方式查环

#### 题目：朋友圈（Friend Circles）

**题目描述**：
给定一个 `n x n` 的矩阵 `M`，表示一个班级的朋友关系。如果 `M[i][j] = 1`，表示第 `i` 个学生和第 `j` 个学生是直接朋友关系；否则，`M[i][j] = 0`。朋友关系具有传递性，即如果 A 是 B 的朋友，B 是 C 的朋友，那么 A 也是 C 的朋友（ABC合并为1个朋友圈）。求这个班级中有多少个朋友圈。

**示例**：
```javascript
输入: M = [
  [1, 1, 0],
  [1, 1, 0],
  [0, 0, 1]
]
输出: 2
解释: 
第 0 个和第 1 个学生是直接朋友，所以他们在一个朋友圈。
第 2 个学生没有朋友，所以他单独一个朋友圈。
```

---

#### 解题思路：并查集（Union-Find）

1. **并查集的核心思想**：
   - 并查集是一种用于管理元素分组的数据结构，支持两种操作：
     - **查找（Find）**：查找某个元素所属的集合（通常用根节点表示）。
     - **合并（Union）**：将两个集合合并为一个集合。
   - 通过路径压缩和按秩合并优化，可以使得并查集的操作接近常数时间复杂度。

2. **算法流程**：
   - 初始化并查集，每个学生最初都是一个独立的集合。
   - 遍历矩阵 `M`，如果 `M[i][j] = 1`，则将学生 `i` 和学生 `j` 合并到同一个集合。
   - 最终统计有多少个独立的集合（即朋友圈的数量）。

---

#### 代码实现

```javascript
class UnionFind {
    constructor(n) {
        this.parent = new Array(n).fill(0).map((_, index) => index); // 初始化父节点
        this.rank = new Array(n).fill(1); // 初始化秩（树的高度）
        this.count = n; // 初始集合数量
    }

    // 查找根节点（路径压缩）
    find(x) {
        if (this.parent[x] !== x) {
            // 假如x = 2, parent[2] = 0, 那么证明x的根节点需要改变指向为0，不再是自身2
            // 改变了根节点的出发点是为了按秩合并时查到对应的树的高度
            this.parent[x] = this.find(this.parent[x]); // 路径压缩
        }
        return this.parent[x];
    }

    // 合并两个集合（按秩合并）
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        if (rootX === rootY) return; // 已经在同一个集合

        // 按秩合并
        if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
        this.count--; // 集合数量减 1
    }

    // 返回集合数量
    getCount() {
        return this.count;
    }
}

function findCircleNum(M) {
    const n = M.length;
    const uf = new UnionFind(n); // 初始化并查集

    // 遍历矩阵，合并朋友关系
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (M[i][j] === 1) {
                uf.union(i, j); // 合并学生 i 和学生 j
            }
        }
    }

    return uf.getCount(); // 返回朋友圈数量
}

// 测试用例
const M = [
  [1, 1, 0],
  [1, 1, 0],
  [0, 0, 1]
];
console.log(findCircleNum(M)); // 输出: 2
```

---

#### 复杂度分析

- **时间复杂度**：`O(n^2 * α(n))`，其中 `n` 是学生的数量，`α(n)` 是反阿克曼函数，接近于常数。
  - 初始化并查集需要 `O(n)`。
  - 遍历矩阵需要 `O(n^2)`。
  - 每次 `find` 和 `union` 操作的时间复杂度接近 `O(1)`。
- **空间复杂度**：`O(n)`，用于存储并查集的父节点和秩。

---

#### 总结

并查集是一种高效处理分组和连通性问题的数据结构。在本题中：
1. **初始化**：每个学生最初都是一个独立的集合。
2. **合并**：遍历矩阵，将直接朋友关系的学生合并到同一个集合。
3. **统计**：最终统计独立的集合数量，即为朋友圈的数量。

并查集通过路径压缩和按秩合并优化，使得操作效率非常高，适用于处理大规模数据的分组问题。

### 13. **前缀和与差分**
   - **特点**：通过预处理数组来快速计算区间和或区间更新。
   - **适用场景**：区间求和、区间更新等问题，如子数组和为 K、航班预订统计等。差分数组是一种高效处理区间增减操作的技巧，特别适用于多次区间修改后求最终结果的场景。它的核心思想是将区间操作转换为两个端点的操作，从而将时间复杂度从 O(m*n) 优化到 O(n + m)（m 是操作次数，n 是数组长度）。

#### 题目：航班预订统计

**题目描述**  
给定 `n` 个航班，编号从 `1` 到 `n`。初始时所有航班座位数为 `0`。  
输入一个数组 `bookings`，其中 `bookings[i] = [i, j, k]` 表示从航班 `i` 到 `j`（包含 `i` 和 `j`）的每个航班预订了 `k` 个座位。  
要求返回一个长度为 `n` 的数组，表示每个航班最终的座位总数。

**示例**  
输入：  
```javascript
bookings = [[1,2,10], [2,3,20]], n = 3
```
输出：  
```
[10, 30, 20]
```
**解释**  
- 第一个预订记录 `[1,2,10]`：航班1和2各增加10个座位，此时座位数为 `[10,10,0]`。  
- 第二个预订记录 `[2,3,20]`：航班2和3各增加20个座位，此时座位数为 `[10,30,20]`。  

---

#### 解题思路  
1. **差分数组**：  
   - 差分数组 `diff` 用于高效处理区间增减操作。  
   - 对区间 `[i, j]` 增加 `k` 时，只需在 `diff[i] += k` 和 `diff[j+1] -= k`。  
2. **前缀和**：  
   - 处理完所有操作后，对差分数组求前缀和即可得到最终结果。

**步骤分解**：  
1. 初始化长度为 `n+2` 的差分数组（避免越界）。  
2. 遍历每个预订记录，更新差分数组。  
3. 计算差分数组的前缀和，得到每个航班的座位数。

---

#### JavaScript 代码实现  
```javascript
function corpFlightBookings(bookings, n) {
    // 初始化差分数组，长度 n+2 确保 j+1 不会越界
    const diff = new Array(n + 2).fill(0);
    
    // 处理每个预订记录，更新差分数组
    for (const [i, j, k] of bookings) {
        diff[i] += k;
        diff[j + 1] -= k;
    }
    
    // 计算前缀和得到结果
    const result = [];
    let current = 0;
    for (let i = 1; i <= n; i++) {
        current += diff[i];
        result.push(current);
    }
    
    return result;
}

// 示例测试
const bookings = [[1, 2, 10], [2, 3, 20]];
const n = 3;
console.log(corpFlightBookings(bookings, n)); // 输出: [10, 30, 20]
```

---

#### 代码解释  
1. **差分数组初始化**：  
   - 长度为 `n+2`，确保处理最大的 `j` 时不会越界。  
2. **更新差分数组**：  
   - 对每个区间 `[i, j]`，在 `diff[i]` 处加 `k`，在 `diff[j+1]` 处减 `k`。  
3. **前缀和计算**：  
   - 遍历差分数组，累加得到每个位置的最终值，即为航班的座位数。  

此方法的时间复杂度为 **O(n + m)**，其中 `m` 是预订记录的数量，效率极高。

### 14. **单调栈/队列**
   - **特点**：利用栈或队列维护单调性，用于解决特定问题。
   - **适用场景**：下一个更大元素、滑动窗口最大值等问题。

#### **题目：每日温度**
给定一个整数数组 `temperatures`，表示每天的温度，返回一个数组 `answer`，其中 `answer[i]` 是第 `i` 天之后需要等待多少天才能遇到更高的温度。如果未来没有更高的温度，则用 `0` 代替。

**示例：**
```javascript
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

---

#### **解题思路**
1. **单调栈的适用性**  
   需要找到数组中每个元素右侧第一个更大的元素，典型的单调栈问题。我们维护一个**从栈底到栈顶单调递减**的栈，栈中保存的是温度的索引（方便计算天数差）。

2. **核心操作**  
   - 遍历每一天的温度 `T[i]`。
   - 如果当前温度 `T[i]` 大于栈顶索引对应的温度 `T[stack[top]]`，则弹出栈顶元素，并记录天数差 `i - stack.pop()`。
   - 将当前索引 `i` 入栈。

---

#### **JavaScript 实现**
```javascript
function dailyTemperatures(temperatures) {
    const n = temperatures.length;
    const answer = new Array(n).fill(0); // 初始化结果数组
    const stack = []; // 维护单调递减栈（存储索引）

    for (let i = 0; i < n; i++) {
        // 当前温度比栈顶温度高时，弹出栈顶并计算天数差
        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {
            const prevIndex = stack.pop();
            answer[prevIndex] = i - prevIndex;
        }
        stack.push(i); // 当前索引入栈
    }
    return answer;
}
```

---

#### **代码解析**
1. **初始化**  
   - `answer` 数组初始化为全 `0`，默认没有更高温度。
   - `stack` 存储未找到更高温度的日期索引。

2. **遍历逻辑**  
   - **循环弹出条件**：当前温度 `T[i]` 大于栈顶索引对应的温度时，说明找到了栈顶日期的更高温度，计算天数差并更新 `answer`。
   - **索引入栈**：处理完栈中所有比当前温度低的元素后，将当前日期索引存入栈中。

---

#### **示例推演**
以输入 `[73,74,75,71,69,72,76,73]` 为例：
- `i=0`（温度73）：栈空，直接入栈 → `stack=[0]`
- `i=1`（温度74）：73 < 74，弹出0，`answer[0]=1-0=1` → 栈空后入栈 → `stack=[1]`
- `i=2`（温度75）：74 < 75，弹出1，`answer[1]=2-1=1` → 栈空后入栈 → `stack=[2]`
- `i=3`（温度71）：75 > 71 → 直接入栈 → `stack=[2,3]`
- `i=4`（温度69）：71 > 69 → 直接入栈 → `stack=[2,3,4]`
- `i=5`（温度72）：69 < 72 → 弹出4，`answer[4]=5-4=1`；71 < 72 → 弹出3，`answer[3]=5-3=2` → 入栈 → `stack=[2,5]`
- `i=6`（温度76）：72 < 76 → 弹出5，`answer[5]=6-5=1`；75 < 76 → 弹出2，`answer[2]=6-2=4` → 入栈 → `stack=[6]`
- `i=7`（温度73）：76 > 73 → 直接入栈 → `stack=[6,7]`

最终 `answer` 为 `[1,1,4,2,1,1,0,0]`。

---

#### **复杂度分析**
- **时间复杂度**：O(n)，每个元素最多入栈和出栈一次。
- **空间复杂度**：O(n)，栈的大小最坏情况下为 n。

---

#### **单调栈/队列的典型应用场景**
- **单调栈**：寻找下一个更大/更小元素（如本题）、直方图最大矩形面积、接雨水问题。
- **单调队列**：滑动窗口最大值/最小值（如「239. 滑动窗口最大值」）。

### 15. **图算法**
   - **特点**：涉及图的遍历、最短路径、拓扑排序等。
   - **适用场景**：图的遍历、最短路径、拓扑排序等问题，如课程表、网络延迟时间等。

#### 题目：判断有向图是否有环

**题目描述**  
给定一个用邻接表表示的有向图（例如 `{ A: ['B'], B: ['C'], C: ['A'] }`），请编写一个函数判断图中是否存在环。

---

#### 解题思路
**核心方法：DFS + 状态标记**  
1. **三种状态**：  
   - `未访问`（未标记）  
   - `访问中`（标记为 1）：表示当前递归路径正在访问该节点  
   - `已访问`（标记为 2）：表示该节点已经被处理过，无需再处理  

2. **DFS过程**：  
   - 如果发现某个邻居处于 `访问中` 状态，说明形成了环。  
   - 处理完所有邻居后，将当前节点标记为 `已访问`，避免重复检查。  

---

#### 代码实现

```javascript
function hasCycle(graph) {
  const visited = {}; // 记录节点状态：undefined=未访问, 1=访问中, 2=已访问

  // 遍历所有节点，确保处理不连通的子图
  for (const node of Object.keys(graph)) {
    if (dfs(node)) return true;
  }
  return false;

  // 递归DFS函数
  function dfs(node) {
    if (visited[node] === 1) return true; // 遇到访问中的节点，发现环！
    if (visited[node] === 2) return false; // 已处理过的节点，无需处理

    visited[node] = 1; // 标记为“访问中”
    // 遍历所有邻居
    for (const neighbor of graph[node] || []) {
      if (dfs(neighbor)) return true;
    }
    visited[node] = 2; // 标记为“已访问”
    return false;
  }
}
```

---

#### 测试案例

**案例1：有环的图**  
```javascript
const graph1 = {
  A: ['B'],
  B: ['C'],
  C: ['A']
};
console.log(hasCycle(graph1)); // 输出 true
```

**案例2：无环的图**  
```javascript
const graph2 = {
  A: ['B'],
  B: ['C'],
  C: [] // C没有后续节点
};
console.log(hasCycle(graph2)); // 输出 false
```

---

#### 通俗解释
想象你在走迷宫，规则是：  
1. 每走到一个新房间，用粉笔标记为“正在探索”。  
2. 如果发现某个房间已经被标记为“正在探索”，说明你绕回了原路，迷宫有环！  
3. 如果探索完所有路径后，把房间标记为“已探索”，避免重复检查。  

代码中的 `visited` 对象就是你的粉笔标记，DFS 就是你的探索过程。通过这种标记方式，可以高效地发现环路。

### 16. **数学方法**
   - **特点**：利用数学公式或性质解决问题。
   - **适用场景**：质数、排列组合、数论等问题，如计数质数、排列序列等。

### 17. **模拟法**
   - **特点**：按照题目要求逐步模拟过程。
   - **适用场景**：复杂的流程模拟问题，如螺旋矩阵、旋转图像等。

### 总结
这些解题模式并非孤立，实际解题时常常需要结合多种方法。掌握这些模式有助于快速识别问题类型并选择合适的算法。